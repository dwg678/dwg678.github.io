{"pages":[{"title":"","text":".about-title { margin-top: 50px; font-size: 20px; margin-bottom: -20px; text-align: center; background-image: linear-gradient(90deg,#a166ab 0,#a166ab 40%,#ef4e7b 45%,#f37055 50%,#ef4e7b 55%,#a166ab 60%,#a166ab 100%); background-size: cover; -webkit-background-clip: text; -webkit-text-fill-color: transparent; } .lrc-title { text-align: center; font-style: italic; font-size: 14px; line-height: 2; } &nbsp;&nbsp;私人FM &nbsp;&nbsp;Video ->点击以下条目开始播放视频,向下滑动查看更多 1.数万人齐聚在北京天安门广场，在国旗下，用歌声唱响《我爱你中国》 2.为了祖国！五星红旗你是我的骄傲 3.#深圳湾点亮中国红#，上演了一场精彩的无人机表演 4.花甲老兵寻战友：希望一起看一次升旗 5.Dream it possible Your browser does not support the video tag. Your browser does not support the video tag. Your browser does not support the video tag. Your browser does not support the video tag. Your browser does not support the video tag. Dream it possible When you dreams come alive you’re unstoppabletake a shot, chase the sun, find the beautifulWe will glow in the dark turning dust to goldAnd we’ll dream it possible &nbsp;&nbsp;如果你也有好音乐或好视频，欢迎下方留言分享哦😊 &nbsp;&nbsp;打赏文章可以点歌哦😊","link":"/music/index.html"},{"title":"","text":"关于我个人简介 计算机软件技术专业，大三学生，目前在一家外包干java实习（累）。 菜鸟码农 喜欢羽毛球 生命不息,奔腾不止 程序人生,永不止步 博客 自❤️2019.07.19❤️以运行 0天 0小时 00分00秒! 没有文笔，搭建博客只想能记录下自己学习过程中踩过的坑，同时帮助自己总结。 window.onload = function(){ // 开始时间 var start = new Date(\"2019/7/19 22:00:00\").getTime(); setInterval(function(){ // 现在 var now = new Date().getTime(); // 运行总时间 var run = now - start; // 总秒 var sumSeconds = parseInt(run / 1000); // 天数 var d = parseInt(sumSeconds / 86400); // 小时 var h = parseInt(sumSeconds % 86400 / 3600); // 分钟 var min = size(parseInt(sumSeconds / 60 % 60)); // 秒 var m = size(parseInt(sumSeconds % 60)); // 插入 document.querySelector('#runtime').innerHTML = d + \"天 \" + h + \"小时 \" + min + \"分\" + m + \"秒\"; }, 1000) // 小于10的数，前边增加一个0 function size(d){ return d < 10 ? '0' + d : d; } } 记录 16:56/09/22/2019 you got a dream,you gotta protect it.— 《当幸福来敲门》 10:50/09/01/2019 You can’t kill the deep roots by cutting off a few top branches.一棵树不会因为顶端的枝桠被截断就是去生命。— 《天才捕手》 18:27/08/25/2019 我跑步从不听音乐，因为我觉得听自己的呼吸是跑步中最美的音乐。— 白岩松 16:14/08/18/2019 你写下的每一个bug，都是人类反抗被人工智能统治的一颗子弹 2019余下时间的计划16:17/08/18/2019 flag 学完买回来没翻过的大话数据结构 实习之余扎实自己的java基础知识 学习SpringBoot、SpringCloud。 强化自己的前端技术 完成一个微服务项目 偶尔跑步，冲冲冲 每天记单词学英语 明白自己现在的处境，争取毕业时，能够稳定下来 居安思危，多思考关注相关专业前景，生活环境","link":"/about/index.html"},{"title":"","text":"爱拍照也爱生活。这里是记录，也是见证。佛系跟新 设备: &ensp;战斗3年的iPhone 6s 以下照片禁止转载。 待续…","link":"/album/index.html"}],"posts":[{"title":"AJAX复习笔记","text":"趁周末整理下笔记AJAX：异步的 JavaScript 和 XML 概念： Asynchronous JavaScript And XML 异步的JavaScript 和 XML 客户端和服务端互相通信的基础上&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.同步：客户端必须等待服务端的响应，在等待的期间客户端不能做其他的操作。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2.异步：客户端不需要等待服务器端的响应，在服务器处理请求的过程中，客户端也可以做其他的操作 AJAX的最大优点:在不需要重新刷新整个页面的情况下，可以和服务器交换数据更新部分页面内容 AJAX不是新的语言 只是一种标准的新方法.ajax使用与浏览器平台无关. 实现方式： AJAX 是浏览器提供的一套 API，可以通过 JavaScript 调用，从而实现通过代码控制请求与响应，实现网络编程。 jQuery 专门针对 AJAX 做了一套封装，功能十分完善，这也是目前使用最多的。(下面我们会用jQuery的方式来演示) 1、$ajax()&emsp;&emsp; 语法：$.ajax({键值对}) 1234567891011121314151617 //使用 $.ajax()发送异步请求$.ajax({ url:\"ajaxServlet1111\" , // 请求路径 type:\"POST\" , //请求方式 //data: \"username=jack&amp;age=23\",//请求参数 data:{\"username\":\"jack\",\"age\":23}, success:function (data) { alert(data); },//响应成功后的回调函数 error:function () { alert(\"出错啦...\") },//表示如果请求响应出现错误，会执行的回调函数 dataType:\"text\"//设置接受到的响应数据的格式 }); 2、$.get()发送get请求&emsp;&emsp;语法：$.get(url, [data], [callback], [type])&emsp;&emsp;参数：&emsp;&emsp;&emsp;&emsp;url：请求路径&emsp;&emsp;&emsp;&emsp; data：请求参数&emsp;&emsp;&emsp;&emsp;callback：回调函数&emsp;&emsp;&emsp;&emsp;type：响应结果的类型 123$.get(\"ajaxServlet\",{username:\"rose\"},function (data) { alert(data); },\"text\"); 3、$.post()发送post请求&emsp;&emsp;语法：$.post(url, [data], [callback], [type])&emsp;&emsp;参数：&emsp;&emsp;&emsp;&emsp; url：请求路径&emsp;&emsp;&emsp;&emsp; data：请求参数&emsp;&emsp;&emsp;&emsp;callback：回调函数&emsp;&emsp;&emsp;&emsp; type：响应结果的类型 123$.post(\"ajaxServlet\",{username:\"rose\"},function (data) { alert(data); },\"text\");","link":"/2019/09/22/AJAX复习笔记/"},{"title":"My-First-Blog","text":"Hello World!","link":"/2019/07/19/my-first-blog/"},{"title":"JavaWeb三大组件之Filter复习笔记","text":"Filter：过滤器 概念： 生活中的过滤器：净水器，空气进化器，土匪 Web中的过滤器：当用户访问服务器资源时，可以将请求拦截下来，完成一些特殊的功能。 过滤器的作用：一般用于完成通用的操作，比如：登录验证，统一字符编码，敏感字过滤…..快速入门： 步骤：&emsp;&emsp;* 定义一个类，实现接口Filter接口；&emsp;&emsp;* 复写接口中的方法；&emsp;&emsp;* 配置拦截路径： 可以在web.xml中写配置文件， 也可以用注解的方式配置拦截路径。 代码： 123456789101112131415161718192021222324 //使用注解的方式配置拦截路径，这里的（\"/user\"）表示访问/user里面的所有资源都会执行该过滤器，如果写成（\"/*\"）则表示访问所有资源之前，都会执行该过滤器 @WebFilter(\"/user\") public class FilterDemo1 implements Filter { //init：初始化方法，在创建Filter时自动调用，当我们需要初始化参数的时候可以写入该方法里。 public void init(FilterConfig filterConfig) throws ServletException { } //doFilter：拦截到要执行的请求时，doFilter就会执行，这里面我们写拦截之后需要做的操作，也就是预处理操作。 public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException { //在这里写拦截之后执行的代码，然后再执行放行代码 //放行：拦截之后，做完预处理操作后，放行。 filterChain.doFilter(servletRequest,servletResponse); //放行代码执行之后，会访问被拦截的资源，当请求返回的时候会从这里开始执行 } //destroy：销毁方法，在销毁是自动调用 public void destroy() { } } 过滤器细节：&emsp;1.web.xml配置：123456789&lt;filter&gt; &lt;filter-name&gt;demo1&lt;/filter-name&gt; &lt;filter-class&gt;cn.itcast.web.filter.FilterDemo1&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;demo1&lt;/filter-name&gt; &lt;!-- 拦截路径 --&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; &emsp;2. 过滤器执行流程：&emsp;&emsp;&emsp;&emsp;1. 被拦截执行过滤器&emsp;&emsp;&emsp;&emsp;2. 执行放行后的资源&emsp;&emsp;&emsp;&emsp;3. 返回时执行放行代码下边的代码 &emsp;3. 过滤器生命周期方法&emsp;&emsp;&emsp;&emsp;1. init:在服务器启动后，会创建Filter对象，然后调用init方法。只执行一次。用于加载资源&emsp;&emsp;&emsp;&emsp;2. doFilter:每一次请求被拦截资源时，会执行。执行多次&emsp;&emsp;&emsp;&emsp;3. destroy:在服务器关闭后，Filter对象被销毁。如果服务器是正常关闭，则会执行destroy方法。只执行一次。用于释放资源 &emsp;4.过滤器配置详解&emsp;&emsp;&emsp;&emsp; 1. 拦截路径配置&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;具体资源路径：/index.jsp &emsp;只有访问index.jsp资源时，过滤器才会被执行&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;拦截目录：/user/* &emsp;访问/user下的所有资源时，过滤器都会被执行&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;后缀名拦截：*.jsp &emsp;访问所有后缀名为jsp资源时，过滤器都会被执行&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;拦截所有资源：/* &emsp;访问所有资源时，过滤器都会被执行 &emsp;&emsp;&emsp;&emsp; 2. 拦截方式配置：资源被访问的方式&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp; 注解配置：&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;设置dispatcherTypes属性&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;1.REQUEST：默认值。浏览器直接请求资源&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;2.FORWARD：转发访问资源&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;3.INCLUDE：包含访问资源&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;4.ERROR：错误跳转资源&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;5.ASYNC：异步访问资源&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;web.xml配置:&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp; 设置标签即可 &emsp;5. 过滤器链(配置多个过滤器)&emsp;&emsp;&emsp;&emsp;&emsp;它可以指向下一个资源，如果还有过滤器，则继续进行下一次的过滤，如果没有过滤器，则会指向资源（servlet）。&emsp;&emsp;&emsp;&emsp;&emsp;执行顺序：如果有两个过滤器：过滤器A和过滤器B&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp; 1. 过滤器A&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp; 2. 过滤器B&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp; 3. 资源执行&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp; 4. 过滤器B&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp; 5. 过滤器A&emsp;&emsp;&emsp;&emsp;&emsp;过滤器先后顺序问题：&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp; 1. 注解配置：按照类名的字符串比较规则比较，值小的先执行&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;* 如： AFilter 和 BFilter，AFilter就先执行了。&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp; 2. web.xml配置： 谁定义在上边，谁先执行","link":"/2019/09/01/JavaWeb三大组件之Filter复习笔记/"},{"title":"SSM插入时间格式，读出来只显日期不显时间","text":"SSM时间戳不显示时分秒 今天在使用SSM框架做东西，需要用到时间控件，给实体类也加了@DateTimeFormat(pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;)，但是调用出来前台只显示年月日，没有时分秒。后来发现问题所在，就是MyBatis反向工程日期类型默认是Date，取值和存值都没有时分秒。 解决方法： 将数据库中的Date类型改为TIMESTAMP(我用的是oracle数据库) 将mapper中获取date类型字段类型改为TIMESTAMP 重启tomcat，如果不是其他原因，现在就可以看到完整的日期时间了。","link":"/2019/08/16/ssm时间戳不显示时间问题/"},{"title":"Redis笔记","text":"好记性不如烂笔头Redis：是一款高性能的NOSQL系列的非关系型数据库 概念： 什么是redis Redis:REmote DIctionary Server(远程字典服务器) 是完全开源免费的，用C语言编写的，遵守BSD协议，是一个高性能的(key/value)分布式内存数据库，基于内存运行并支持持久化的NoSQL数据库，是当前最热门的NoSql数据库之一,也被人们称为数据结构服务器。 Redis 与其他 key - value 缓存产品有以下三个特点： Redis支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用； Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储； Redis支持数据的备份，即master-slave模式的数据备份； redis的应用场景 缓存（数据查询、短连接、新闻内容、商品内容等等） 聊天室的在线好友列表 任务队列。（秒杀、抢购、12306等等） 应用排行榜 网站访问统计 数据过期处理（可以精确到毫秒） 分布式集群架构中的session分离 下载安装 官网：https://redis.io 中文网：http://www.redis.net.cn/ 解压直接可以使用： redis.windows.conf：配置文件 redis-cli.exe：redis的客户端 redis-server.exe：redis服务器端 启动后基础知识 单进程 单进程模型来处理客户端的请求。对读写等事件的响应是通过对epoll函数的包装来做到的。Redis的实际处理速度完全依靠主进程的执行效率； epoll是Linux内核为处理大批量文件描述符而作了改进的epoll，是Linux下多路复用IO接口select/poll的增强版本，它能显著提高程序在大量并发连接中只有少量活跃的情况下的系统CPU利用率； redis数据库的一些概念及操作 默认16个数据库，类似数组下表从零开始，初始默认使用零号库； 统一密码管理，16个库都是同样密码，要么都OK要么一个也连接不上，redis默认端口是6379； select命令切换数据库：select 0-15； dbsize：查看当前数据库的key的数量； flushdb：清空当前库； flushall；通杀全部库； Redis数据结构redis存储的是：key,value格式的数据，其中key都是字符串，value有5种不同的数据结构 1.字符串类型 string string是redis最基本的类型，你可以理解成与Memcached一模一样的类型，一个key对应一个value； string类型是二进制安全的。意思是redis的string可以包含任何数据。如jpg图片或者序列化的对象 ； string类型是Redis最基本的数据类型，一个redis中字符串value最多可以是512M； 2. 哈希类型 hash ： (map格式) redis的hash 是一个键值对集合； redis hash是一个string类型的field和value的映射表，hash特别适合用于存储对象； 类似Java里面的Map&lt;String,Object&gt;； 3.列表类型 list ：（linkedlist格式。支持重复元素）&emsp;&emsp;redis 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素导列表的头部（左边）或者尾部（右边）。它的底层实际是个链表。 4. 集合类型 set ： （不允许重复元素）&emsp;&emsp;redis的set是string类型的无序集合。它是通过HashTable实现的。 4. 有序集合类型 sortedset：（不允许重复元素，且元素有顺序） redis的sortedset和 set 一样也是string类型元素的集合,且不允许重复的成员； 不同的是每个元素都会关联一个double类型的分数； redis正是通过分数来为集合中的成员进行从小到大的排序。sortedset的成员是唯一的,但分数(score)却可以重复； 常用命令操作redis常见数据类型操作命令参考网址http://redisdoc.com/ 字符串类型 String SET key value （存储：将字符串值 value 关联到 key） GET key （获取：返回与键 key 相关联的字符串值） DEL key （删除：删除给定的 key ） APPEND key value （ APPEND 命令将把 value 追加到键 key 现有值的末尾，没有 key 就自动添加） STRLEN key （返回键 key 储存的字符串值的长度） 哈希类型 hash HSET key field value （存储：将哈希表 hash 中域 field 的值设置为 value） HGET key field （获取：获取指定的field对应的值） HDEL key field （删除：删除哈希表 key 中的一个或多个指定域，不存在的域将被忽略） HMSET key field value [field value …] （同时将多个 field-value (域-值)对设置到哈希表 key 中） HMGET key field [field …] （返回哈希表 key 中，一个或多个给定域的值） HGETALL key （返回哈希表 key 中，所有的域和值） 列表类型 list LPUSH key value （添加：将元素加入列表左边表头） RPUSH key value （添加：将元素加入列表右边表尾） LRANGE key start stop （返回列表 key 中指定区间内的元素，区间以偏移量 start 和 stop 指定） LPOP key （删除：删除列表最左边的元素，并将元素返回） RPOP key （删除：删除列表最右边的元素，并将元素返回） LINDEX key index （返回列表 key 中，下标为 index的元素） 集合类型 set SADD key member [member …] （存储：将一个或多个 member 元素加入到集合 key 当中，已经存在于集合的 member元素将被忽略） SMEMBERS key （获取：返回集合 key 中的所有成员） SREM key member [member …] （移除集合 key 中的一个或多个 member 元素，不存在的 member 元素会被忽略） SISMEMBER key member （判断 member元素是否集合 key 的成员） 有序集合类型 sortedset ZADD key score member [[score member] [score member] …] （储存：将一个或多个 member 元素及其 score 值加入到有序集 key 当中） ZRANGE key start stop [WITHSCORES] （获取：返回有序集 key 中，指定区间内的成员，其中成员的位置按 score 值递增(从小到大)来排列） ZREM key member [member …] （删除：移除有序集 key 中的一个或多个成员，不存在的成员将被忽略） redis 键(key) –常用命令介绍 keys *：查看所有 key ； exists key的名字：判断某个 key 是否存在； move key dbID（0-15）： 当前库就没有了，被移除了； expire key 秒钟： 为给定的 key 设置过期时间； ttl key： 查看还有多少秒过期，-1表示永不过期，-2表示已过期； type key： 查看你的 key 是什么类型； 持久化redis是一个内存数据库，当redis服务器重启，获取电脑重启，数据会丢失，我们可以将redis内存中的数据持久化保存到硬盘的文件中。 RDB(Redis DataBase) 在指定的时间间隔内将内存中的数据集快照写入磁盘，也就是行话讲的Snapshot快照，它恢复时是将快照文件直接读到内存里；RDB保存的是dump.rdb文件；Redis会单独创建（fork）一个子进程来进行持久化，会先将数据写入到一个临时文件中，待持久化过程都结束了，再用这个临时文件替换上次持久化好的文件。整个过程中，主进程是不进行任何IO操作的，这就确保了极高的性能如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那RDB方式要比AOF方式更加的高效。RDB的缺点是最后一次持久化后的数据可能丢失；fork：复制一个与当前进程一样的进程。新进程的所有数据（变量、环境变量、程序计数器等）数值都和原进程一致，但是是一个全新的进程，并作为原进程的子进程； 在一定的间隔时间中，检测key的变化情况，然后持久化数据 编辑redis.windwos.conf文件 123456#after 900 sec (15 min) if at least 1 key changedsave 900 1#after 300 sec (5 min) if at least 10 keys changedsave 300 10#after 60 sec if at least 10000 keys changedsave 60 10000 重新启动redis服务器，并指定配置文件名称 1D:\\redis\\windows-64\\redis-2.8.9&gt;redis-server.exe redis.windows.conf AOF(Append Only File) 以日志的形式来记录每个写操作，将Redis执行过的所有写指令记录下来(读操作不记录)，只许追加文件但不可以改写文件，redis启动之初会读取该文件重新构建数据，换言之，redis重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作（AOF保存的是appendonly.aof文件）； 编辑redis.windwos.conf文件appendonly no（关闭aof） –&gt; appendonly yes （开启aof）# appendfsync always ： 每一次操作都进行持久化appendfsync everysec： 每隔一秒进行一次持久化# appendfsync no ： 不进行持久化","link":"/2019/10/03/Redis笔记/"}],"tags":[{"name":"AJAX","slug":"AJAX","link":"/tags/AJAX/"},{"name":"笔记","slug":"笔记","link":"/tags/笔记/"},{"name":"Filter","slug":"Filter","link":"/tags/Filter/"},{"name":"拦截器","slug":"拦截器","link":"/tags/拦截器/"},{"name":"ssm","slug":"ssm","link":"/tags/ssm/"},{"name":"时间格式","slug":"时间格式","link":"/tags/时间格式/"},{"name":"Redis","slug":"Redis","link":"/tags/Redis/"}],"categories":[{"name":"前端","slug":"前端","link":"/categories/前端/"},{"name":"JAVA","slug":"JAVA","link":"/categories/JAVA/"},{"name":"JavaScript","slug":"前端/JavaScript","link":"/categories/前端/JavaScript/"},{"name":"JavaWeb","slug":"JAVA/JavaWeb","link":"/categories/JAVA/JavaWeb/"},{"name":"SSM","slug":"JAVA/SSM","link":"/categories/JAVA/SSM/"},{"name":"数据库","slug":"数据库","link":"/categories/数据库/"},{"name":"Redis","slug":"数据库/Redis","link":"/categories/数据库/Redis/"}]}
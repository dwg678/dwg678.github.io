{"pages":[{"title":"","text":"关于我个人简介 计算机软件技术专业，大三学生，目前在一家外包干java实习（累）。 没有文笔，搭建博客只想能记录下自己学习过程中踩过的坑，同时帮助自己总结。 码畜一枚 程序人生,永不止步 博客 自❤️2019.07.19❤️以运行 0天 0小时 00分00秒! 博客参照网友博客所做，感谢作者的艰辛付出。 记录 10:50/09/01/2019 You can’t kill the deep roots by cutting off a few top branches.一棵树不会因为顶端的枝桠被截断就是去生命。— 《天才捕手》 18:27/08/25/2019 我跑步从不听音乐，因为我觉得听自己的呼吸是跑步中最美的音乐。— 白岩松 16:14/08/18/2019 你写下的每一个bug，都是人类反抗被人工智能统治的一颗子弹 2019余下时间的计划16:17/08/18/2019 flag 学完买回来没翻过的大话数据结构 实习之余扎实自己的java基础知识 学习SpringBoot、SpringCloud。 强化自己的前端技术 完成一个微服务项目 偶尔跑步，冲冲冲 每天记单词学英语 明白自己现在的处境，争取毕业时，能够稳定下来 居安思危，多思考关注相关专业前景，生活环境 window.onload = function(){ // 开始时间 var start = new Date(\"2019/7/19 22:00:00\").getTime(); setInterval(function(){ // 现在 var now = new Date().getTime(); // 运行总时间 var run = now - start; // 总秒 var sumSeconds = parseInt(run / 1000); // 天数 var d = parseInt(sumSeconds / 86400); // 小时 var h = parseInt(sumSeconds % 86400 / 3600); // 分钟 var min = size(parseInt(sumSeconds / 60 % 60)); // 秒 var m = size(parseInt(sumSeconds % 60)); // 插入 document.querySelector('#runtime').innerHTML = d + \"天 \" + h + \"小时 \" + min + \"分\" + m + \"秒\"; }, 1000) // 小于10的数，前边增加一个0 function size(d){ return d < 10 ? '0' + d : d; } }","link":"/about/index.html"},{"title":"","text":"爱拍照也爱生活。这里是记录，也是见证。佛系跟新 设备: &ensp;战斗3年的iPhone 6s 以下照片转载请注明出处。 待续…","link":"/album/index.html"},{"title":"","text":"2019.09.09 23:47这个页面还没弄好，有空在折腾&gt;&gt;&gt;&gt;&gt;","link":"/music/index.html"}],"posts":[{"title":"JavaWeb三大组件之Filter复习笔记","text":"Filter：过滤器 概念： 生活中的过滤器：净水器，空气进化器，土匪 Web中的过滤器：当用户访问服务器资源时，可以将请求拦截下来，完成一些特殊的功能。 过滤器的作用：一般用于完成通用的操作，比如：登录验证，统一字符编码，敏感字过滤…..快速入门： 步骤：&emsp;&emsp;* 定义一个类，实现接口Filter接口；&emsp;&emsp;* 复写接口中的方法；&emsp;&emsp;* 配置拦截路径： 可以在web.xml中写配置文件， 也可以用注解的方式配置拦截路径。 代码：123456789101112131415161718192021222324 //使用注解的方式配置拦截路径，这里的（\"/user\"）表示访问/user里面的所有资源都会执行该过滤器，如果写成（\"/*\"）则表示访问所有资源之前，都会执行该过滤器 @WebFilter(\"/user\") public class FilterDemo1 implements Filter { //init：初始化方法，在创建Filter时自动调用，当我们需要初始化参数的时候可以写入该方法里。 public void init(FilterConfig filterConfig) throws ServletException { } //doFilter：拦截到要执行的请求时，doFilter就会执行，这里面我们写拦截之后需要做的操作，也就是预处理操作。 public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException { //在这里写拦截之后执行的代码，然后再执行放行代码 //放行：拦截之后，做完预处理操作后，放行。 filterChain.doFilter(servletRequest,servletResponse); //放行代码执行之后，会访问被拦截的资源，当请求返回的时候会从这里开始执行 } //destroy：销毁方法，在销毁是自动调用 public void destroy() { } } 过滤器细节：&emsp;1.web.xml配置：123456789&lt;filter&gt; &lt;filter-name&gt;demo1&lt;/filter-name&gt; &lt;filter-class&gt;cn.itcast.web.filter.FilterDemo1&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;demo1&lt;/filter-name&gt; &lt;!-- 拦截路径 --&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; &emsp;2. 过滤器执行流程：&emsp;&emsp;&emsp;&emsp;1. 被拦截执行过滤器&emsp;&emsp;&emsp;&emsp;2. 执行放行后的资源&emsp;&emsp;&emsp;&emsp;3. 返回时执行放行代码下边的代码 &emsp;3. 过滤器生命周期方法&emsp;&emsp;&emsp;&emsp;1. init:在服务器启动后，会创建Filter对象，然后调用init方法。只执行一次。用于加载资源&emsp;&emsp;&emsp;&emsp;2. doFilter:每一次请求被拦截资源时，会执行。执行多次&emsp;&emsp;&emsp;&emsp;3. destroy:在服务器关闭后，Filter对象被销毁。如果服务器是正常关闭，则会执行destroy方法。只执行一次。用于释放资源 &emsp;4.过滤器配置详解&emsp;&emsp;&emsp;&emsp; 1. 拦截路径配置&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;具体资源路径：/index.jsp &emsp;只有访问index.jsp资源时，过滤器才会被执行&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;拦截目录：/user/* &emsp;访问/user下的所有资源时，过滤器都会被执行&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;后缀名拦截：*.jsp &emsp;访问所有后缀名为jsp资源时，过滤器都会被执行&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;拦截所有资源：/* &emsp;访问所有资源时，过滤器都会被执行 &emsp;&emsp;&emsp;&emsp; 2. 拦截方式配置：资源被访问的方式&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp; 注解配置：&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;设置dispatcherTypes属性&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;1.REQUEST：默认值。浏览器直接请求资源&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;2.FORWARD：转发访问资源&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;3.INCLUDE：包含访问资源&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;4.ERROR：错误跳转资源&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;5.ASYNC：异步访问资源&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;web.xml配置:&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp; 设置标签即可 &emsp;5. 过滤器链(配置多个过滤器)&emsp;&emsp;&emsp;&emsp;&emsp;它可以指向下一个资源，如果还有过滤器，则继续进行下一次的过滤，如果没有过滤器，则会指向资源（servlet）。&emsp;&emsp;&emsp;&emsp;&emsp;执行顺序：如果有两个过滤器：过滤器A和过滤器B&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp; 1. 过滤器A&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp; 2. 过滤器B&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp; 3. 资源执行&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp; 4. 过滤器B&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp; 5. 过滤器A&emsp;&emsp;&emsp;&emsp;&emsp;过滤器先后顺序问题：&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp; 1. 注解配置：按照类名的字符串比较规则比较，值小的先执行&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;* 如： AFilter 和 BFilter，AFilter就先执行了。&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp; 2. web.xml配置： 谁定义在上边，谁先执行","link":"/2019/09/01/JavaWeb三大组件之Filter复习笔记/"},{"title":"My-First-Blog","text":"你好hexo！","link":"/2019/07/19/my-first-blog/"},{"title":"SSM插入时间格式，读出来只显日期不显时间","text":"SSM时间戳不显示时分秒 今天在使用SSM框架做东西，需要用到时间控件，给实体类也加了@DateTimeFormat(pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;)，但是调用出来前台只显示年月日，没有时分秒。后来发现问题所在，就是MyBatis反向工程日期类型默认是Date，取值和存值都没有时分秒。 解决方法： 将数据库中的Date类型改为TIMESTAMP(我用的是oracle数据库) 将mapper中获取date类型字段类型改为TIMESTAMP 重启tomcat，如果不是其他原因，现在就可以看到完整的日期时间了。","link":"/2019/08/16/ssm时间戳不显示时间问题/"}],"tags":[{"name":"Filter","slug":"Filter","link":"/tags/Filter/"},{"name":"拦截器","slug":"拦截器","link":"/tags/拦截器/"},{"name":"ssm","slug":"ssm","link":"/tags/ssm/"},{"name":"时间格式","slug":"时间格式","link":"/tags/时间格式/"}],"categories":[{"name":"JAVA","slug":"JAVA","link":"/categories/JAVA/"},{"name":"JavaWeb","slug":"JAVA/JavaWeb","link":"/categories/JAVA/JavaWeb/"},{"name":"SSM","slug":"JAVA/SSM","link":"/categories/JAVA/SSM/"}]}
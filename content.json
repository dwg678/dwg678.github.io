{"pages":[{"title":"","text":"个人简介 计算机软件技术专业，大三学生，目前在一家外包干java实习（累）。 菜鸟码农 喜欢羽毛球 生命不息,奔腾不止 程序人生,永不止步 博客 自❤️2019.07.19❤️以运行 0天 0小时 00分00秒! 没有文笔，搭建博客只想能记录下自己学习过程中踩过的坑，同时帮助自己总结。 window.onload = function(){ // 开始时间 var start = new Date(\"2019/7/19 22:00:00\").getTime(); setInterval(function(){ // 现在 var now = new Date().getTime(); // 运行总时间 var run = now - start; // 总秒 var sumSeconds = parseInt(run / 1000); // 天数 var d = parseInt(sumSeconds / 86400); // 小时 var h = parseInt(sumSeconds % 86400 / 3600); // 分钟 var min = size(parseInt(sumSeconds / 60 % 60)); // 秒 var m = size(parseInt(sumSeconds % 60)); // 插入 document.querySelector('#runtime').innerHTML = d + \"天 \" + h + \"小时 \" + min + \"分\" + m + \"秒\"; }, 1000) // 小于10的数，前边增加一个0 function size(d){ return d < 10 ? '0' + d : d; } } 记录 2019.12.27/20:12 梅花香自苦寒来.— 《警世通言·勤奋篇》 2019.10.03/21:07 Winter is coming.— 《权利的游戏》 2019.09.22/16:56 you got a dream,you gotta protect it.— 《当幸福来敲门》 2019.09.01/10:50 You can’t kill the deep roots by cutting off a few top branches.一棵树不会因为顶端的枝桠被截断就是去生命。— 《天才捕手》 2019.08.25/18:27 我跑步从不听音乐，因为我觉得听自己的呼吸是跑步中最美的音乐。— 白岩松 2019.08.18/16:14 你写下的每一个bug，都是人类反抗被人工智能统治的一颗子弹 flag 2019余下时间的计划2019.08.18/16:17 flag 学完买回来没翻过的大话数据结构 实习之余扎实自己的java基础知识 学习SpringBoot、SpringCloud。 强化自己的前端技术 完成一个微服务项目 偶尔跑步，冲冲冲 每天记单词学英语 明白自己现在的处境，争取毕业时，能够稳定下来 居安思危，多思考关注相关专业前景，生活环境","link":"/about/index.html"},{"title":"","text":".about-title { margin-top: 50px; font-size: 20px; margin-bottom: -20px; text-align: center; background-image: linear-gradient(90deg,#a166ab 0,#a166ab 40%,#ef4e7b 45%,#f37055 50%,#ef4e7b 55%,#a166ab 60%,#a166ab 100%); background-size: cover; -webkit-background-clip: text; -webkit-text-fill-color: transparent; } .lrc-title { text-align: center; font-style: italic; font-size: 14px; line-height: 2; } &nbsp;&nbsp;私人FM &nbsp;&nbsp;Video ->点击以下条目开始播放视频,向下滑动查看更多 1.数万人齐聚在北京天安门广场，在国旗下，用歌声唱响《我爱你中国》 2.为了祖国！五星红旗你是我的骄傲 3.#深圳湾点亮中国红#，上演了一场精彩的无人机表演 4.花甲老兵寻战友：希望一起看一次升旗 5.Dream it possible Your browser does not support the video tag. Your browser does not support the video tag. Your browser does not support the video tag. Your browser does not support the video tag. Your browser does not support the video tag. Dream it possible When you dreams come alive you’re unstoppabletake a shot, chase the sun, find the beautifulWe will glow in the dark turning dust to goldAnd we’ll dream it possible &nbsp;&nbsp;如果你也有好音乐或好视频，欢迎下方留言分享哦😊 &nbsp;&nbsp;打赏文章可以点歌哦😊","link":"/music/index.html"},{"title":"","text":"爱拍照也爱生活。这里是记录，也是见证。佛系跟新 设备: &ensp;iPhone 6s 以下照片禁止转载。 待续…","link":"/album/index.html"}],"posts":[{"title":"AJAX复习笔记","text":"趁周末整理下笔记AJAX：异步的 JavaScript 和 XML 概念： Asynchronous JavaScript And XML 异步的JavaScript 和 XML 客户端和服务端互相通信的基础上&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.同步：客户端必须等待服务端的响应，在等待的期间客户端不能做其他的操作。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2.异步：客户端不需要等待服务器端的响应，在服务器处理请求的过程中，客户端也可以做其他的操作 AJAX的最大优点:在不需要重新刷新整个页面的情况下，可以和服务器交换数据更新部分页面内容 AJAX不是新的语言 只是一种标准的新方法.ajax使用与浏览器平台无关. 实现方式： AJAX 是浏览器提供的一套 API，可以通过 JavaScript 调用，从而实现通过代码控制请求与响应，实现网络编程。 jQuery 专门针对 AJAX 做了一套封装，功能十分完善，这也是目前使用最多的。(下面我们会用jQuery的方式来演示) 1、$ajax()&emsp;&emsp; 语法：$.ajax({键值对}) 1234567891011121314151617 //使用 $.ajax()发送异步请求$.ajax({ url:\"ajaxServlet1111\" , // 请求路径 type:\"POST\" , //请求方式 //data: \"username=jack&amp;age=23\",//请求参数 data:{\"username\":\"jack\",\"age\":23}, success:function (data) { alert(data); },//响应成功后的回调函数 error:function () { alert(\"出错啦...\") },//表示如果请求响应出现错误，会执行的回调函数 dataType:\"text\"//设置接受到的响应数据的格式 }); 2、$.get()发送get请求&emsp;&emsp;语法：$.get(url, [data], [callback], [type])&emsp;&emsp;参数：&emsp;&emsp;&emsp;&emsp;url：请求路径&emsp;&emsp;&emsp;&emsp; data：请求参数&emsp;&emsp;&emsp;&emsp;callback：回调函数&emsp;&emsp;&emsp;&emsp;type：响应结果的类型 123$.get(\"ajaxServlet\",{username:\"rose\"},function (data) { alert(data); },\"text\"); 3、$.post()发送post请求&emsp;&emsp;语法：$.post(url, [data], [callback], [type])&emsp;&emsp;参数：&emsp;&emsp;&emsp;&emsp; url：请求路径&emsp;&emsp;&emsp;&emsp; data：请求参数&emsp;&emsp;&emsp;&emsp;callback：回调函数&emsp;&emsp;&emsp;&emsp; type：响应结果的类型 123$.post(\"ajaxServlet\",{username:\"rose\"},function (data) { alert(data); },\"text\");","link":"/2019/09/22/AJAX复习笔记/"},{"title":"My-First-Blog","text":"Hello World!","link":"/2019/07/19/my-first-blog/"},{"title":"SSM插入时间格式，读出来只显日期不显时间","text":"SSM时间戳不显示时分秒 今天在使用SSM框架做东西，需要用到时间控件，给实体类也加了@DateTimeFormat(pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;)，但是调用出来前台只显示年月日，没有时分秒。后来发现问题所在，就是MyBatis反向工程日期类型默认是Date，取值和存值都没有时分秒。 解决方法： 将数据库中的Date类型改为TIMESTAMP(我用的是oracle数据库) 将mapper中获取date类型字段类型改为TIMESTAMP 重启tomcat，如果不是其他原因，现在就可以看到完整的日期时间了。","link":"/2019/08/16/ssm时间戳不显示时间问题/"},{"title":"Redis笔记","text":"好记性不如烂笔头Redis：是一款高性能的NOSQL系列的非关系型数据库 概念： 什么是redis Redis:REmote DIctionary Server(远程字典服务器) 是完全开源免费的，用C语言编写的，遵守BSD协议，是一个高性能的(key/value)分布式内存数据库，基于内存运行并支持持久化的NoSQL数据库，是当前最热门的NoSql数据库之一,也被人们称为数据结构服务器。 Redis 与其他 key - value 缓存产品有以下三个特点： Redis支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用； Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储； Redis支持数据的备份，即master-slave模式的数据备份； redis的应用场景 缓存（数据查询、短连接、新闻内容、商品内容等等） 聊天室的在线好友列表 任务队列。（秒杀、抢购、12306等等） 应用排行榜 网站访问统计 数据过期处理（可以精确到毫秒） 分布式集群架构中的session分离 下载安装 官网：https://redis.io 中文网：http://www.redis.net.cn/ 解压直接可以使用： redis.windows.conf：配置文件 redis-cli.exe：redis的客户端 redis-server.exe：redis服务器端 启动后基础知识 单进程 单进程模型来处理客户端的请求。对读写等事件的响应是通过对epoll函数的包装来做到的。Redis的实际处理速度完全依靠主进程的执行效率； epoll是Linux内核为处理大批量文件描述符而作了改进的epoll，是Linux下多路复用IO接口select/poll的增强版本，它能显著提高程序在大量并发连接中只有少量活跃的情况下的系统CPU利用率； redis数据库的一些概念及操作 默认16个数据库，类似数组下表从零开始，初始默认使用零号库； 统一密码管理，16个库都是同样密码，要么都OK要么一个也连接不上，redis默认端口是6379； select命令切换数据库：select 0-15； dbsize：查看当前数据库的key的数量； flushdb：清空当前库； flushall；通杀全部库； Redis数据结构redis存储的是：key,value格式的数据，其中key都是字符串，value有5种不同的数据结构 1.字符串类型 string string是redis最基本的类型，你可以理解成与Memcached一模一样的类型，一个key对应一个value； string类型是二进制安全的。意思是redis的string可以包含任何数据。如jpg图片或者序列化的对象 ； string类型是Redis最基本的数据类型，一个redis中字符串value最多可以是512M； 2. 哈希类型 hash ： (map格式) redis的hash 是一个键值对集合； redis hash是一个string类型的field和value的映射表，hash特别适合用于存储对象； 类似Java里面的Map&lt;String,Object&gt;； 3.列表类型 list ：（linkedlist格式。支持重复元素）&emsp;&emsp;redis 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素导列表的头部（左边）或者尾部（右边）。它的底层实际是个链表。 4. 集合类型 set ： （不允许重复元素）&emsp;&emsp;redis的set是string类型的无序集合。它是通过HashTable实现的。 4. 有序集合类型 sortedset：（不允许重复元素，且元素有顺序） redis的sortedset和 set 一样也是string类型元素的集合,且不允许重复的成员； 不同的是每个元素都会关联一个double类型的分数； redis正是通过分数来为集合中的成员进行从小到大的排序。sortedset的成员是唯一的,但分数(score)却可以重复； 常用命令操作redis常见数据类型操作命令参考网址http://redisdoc.com/ 字符串类型 String SET key value （存储：将字符串值 value 关联到 key） GET key （获取：返回与键 key 相关联的字符串值） DEL key （删除：删除给定的 key ） APPEND key value （ APPEND 命令将把 value 追加到键 key 现有值的末尾，没有 key 就自动添加） STRLEN key （返回键 key 储存的字符串值的长度） 哈希类型 hash HSET key field value （存储：将哈希表 hash 中域 field 的值设置为 value） HGET key field （获取：获取指定的field对应的值） HDEL key field （删除：删除哈希表 key 中的一个或多个指定域，不存在的域将被忽略） HMSET key field value [field value …] （同时将多个 field-value (域-值)对设置到哈希表 key 中） HMGET key field [field …] （返回哈希表 key 中，一个或多个给定域的值） HGETALL key （返回哈希表 key 中，所有的域和值） 列表类型 list LPUSH key value （添加：将元素加入列表左边表头） RPUSH key value （添加：将元素加入列表右边表尾） LRANGE key start stop （返回列表 key 中指定区间内的元素，区间以偏移量 start 和 stop 指定） LPOP key （删除：删除列表最左边的元素，并将元素返回） RPOP key （删除：删除列表最右边的元素，并将元素返回） LINDEX key index （返回列表 key 中，下标为 index的元素） 集合类型 set SADD key member [member …] （存储：将一个或多个 member 元素加入到集合 key 当中，已经存在于集合的 member元素将被忽略） SMEMBERS key （获取：返回集合 key 中的所有成员） SREM key member [member …] （移除集合 key 中的一个或多个 member 元素，不存在的 member 元素会被忽略） SISMEMBER key member （判断 member元素是否集合 key 的成员） 有序集合类型 sortedset ZADD key score member [[score member] [score member] …] （储存：将一个或多个 member 元素及其 score 值加入到有序集 key 当中） ZRANGE key start stop [WITHSCORES] （获取：返回有序集 key 中，指定区间内的成员，其中成员的位置按 score 值递增(从小到大)来排列） ZREM key member [member …] （删除：移除有序集 key 中的一个或多个成员，不存在的成员将被忽略） redis 键(key) –常用命令介绍 keys *：查看所有 key ； exists key的名字：判断某个 key 是否存在； move key dbID（0-15）： 当前库就没有了，被移除了； expire key 秒钟： 为给定的 key 设置过期时间； ttl key： 查看还有多少秒过期，-1表示永不过期，-2表示已过期； type key： 查看你的 key 是什么类型； 持久化redis是一个内存数据库，当redis服务器重启，获取电脑重启，数据会丢失，我们可以将redis内存中的数据持久化保存到硬盘的文件中。 RDB(Redis DataBase) 在指定的时间间隔内将内存中的数据集快照写入磁盘，也就是行话讲的Snapshot快照，它恢复时是将快照文件直接读到内存里；RDB保存的是dump.rdb文件；Redis会单独创建（fork）一个子进程来进行持久化，会先将数据写入到一个临时文件中，待持久化过程都结束了，再用这个临时文件替换上次持久化好的文件。整个过程中，主进程是不进行任何IO操作的，这就确保了极高的性能如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那RDB方式要比AOF方式更加的高效。RDB的缺点是最后一次持久化后的数据可能丢失；fork：复制一个与当前进程一样的进程。新进程的所有数据（变量、环境变量、程序计数器等）数值都和原进程一致，但是是一个全新的进程，并作为原进程的子进程； 在一定的间隔时间中，检测key的变化情况，然后持久化数据 编辑redis.windwos.conf文件 123456#after 900 sec (15 min) if at least 1 key changedsave 900 1#after 300 sec (5 min) if at least 10 keys changedsave 300 10#after 60 sec if at least 10000 keys changedsave 60 10000 重新启动redis服务器，并指定配置文件名称 1D:\\redis\\windows-64\\redis-2.8.9&gt;redis-server.exe redis.windows.conf AOF(Append Only File) 以日志的形式来记录每个写操作，将Redis执行过的所有写指令记录下来(读操作不记录)，只许追加文件但不可以改写文件，redis启动之初会读取该文件重新构建数据，换言之，redis重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作（AOF保存的是appendonly.aof文件）； 编辑redis.windwos.conf文件appendonly no（关闭aof） –&gt; appendonly yes （开启aof）# appendfsync always ： 每一次操作都进行持久化appendfsync everysec： 每隔一秒进行一次持久化# appendfsync no ： 不进行持久化","link":"/2019/10/03/Redis笔记/"},{"title":"JavaWeb三大组件之Filter复习笔记","text":"Filter：过滤器 概念： 生活中的过滤器：净水器，空气进化器，土匪 Web中的过滤器：当用户访问服务器资源时，可以将请求拦截下来，完成一些特殊的功能。 过滤器的作用：一般用于完成通用的操作，比如：登录验证，统一字符编码，敏感字过滤…..快速入门： 步骤：&emsp;&emsp;* 定义一个类，实现接口Filter接口；&emsp;&emsp;* 复写接口中的方法；&emsp;&emsp;* 配置拦截路径： 可以在web.xml中写配置文件， 也可以用注解的方式配置拦截路径。 代码： 123456789101112131415161718192021222324 //使用注解的方式配置拦截路径，这里的（\"/user\"）表示访问/user里面的所有资源都会执行该过滤器，如果写成（\"/*\"）则表示访问所有资源之前，都会执行该过滤器 @WebFilter(\"/user\") public class FilterDemo1 implements Filter { //init：初始化方法，在创建Filter时自动调用，当我们需要初始化参数的时候可以写入该方法里。 public void init(FilterConfig filterConfig) throws ServletException { } //doFilter：拦截到要执行的请求时，doFilter就会执行，这里面我们写拦截之后需要做的操作，也就是预处理操作。 public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException { //在这里写拦截之后执行的代码，然后再执行放行代码 //放行：拦截之后，做完预处理操作后，放行。 filterChain.doFilter(servletRequest,servletResponse); //放行代码执行之后，会访问被拦截的资源，当请求返回的时候会从这里开始执行 } //destroy：销毁方法，在销毁是自动调用 public void destroy() { } } 过滤器细节：&emsp;1.web.xml配置：123456789&lt;filter&gt; &lt;filter-name&gt;demo1&lt;/filter-name&gt; &lt;filter-class&gt;cn.itcast.web.filter.FilterDemo1&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;demo1&lt;/filter-name&gt; &lt;!-- 拦截路径 --&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; &emsp;2. 过滤器执行流程：&emsp;&emsp;&emsp;&emsp;1. 被拦截执行过滤器&emsp;&emsp;&emsp;&emsp;2. 执行放行后的资源&emsp;&emsp;&emsp;&emsp;3. 返回时执行放行代码下边的代码 &emsp;3. 过滤器生命周期方法&emsp;&emsp;&emsp;&emsp;1. init:在服务器启动后，会创建Filter对象，然后调用init方法。只执行一次。用于加载资源&emsp;&emsp;&emsp;&emsp;2. doFilter:每一次请求被拦截资源时，会执行。执行多次&emsp;&emsp;&emsp;&emsp;3. destroy:在服务器关闭后，Filter对象被销毁。如果服务器是正常关闭，则会执行destroy方法。只执行一次。用于释放资源 &emsp;4.过滤器配置详解&emsp;&emsp;&emsp;&emsp; 1. 拦截路径配置&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;具体资源路径：/index.jsp &emsp;只有访问index.jsp资源时，过滤器才会被执行&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;拦截目录：/user/* &emsp;访问/user下的所有资源时，过滤器都会被执行&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;后缀名拦截：*.jsp &emsp;访问所有后缀名为jsp资源时，过滤器都会被执行&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;拦截所有资源：/* &emsp;访问所有资源时，过滤器都会被执行 &emsp;&emsp;&emsp;&emsp; 2. 拦截方式配置：资源被访问的方式&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp; 注解配置：&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;设置dispatcherTypes属性&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;1.REQUEST：默认值。浏览器直接请求资源&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;2.FORWARD：转发访问资源&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;3.INCLUDE：包含访问资源&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;4.ERROR：错误跳转资源&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;5.ASYNC：异步访问资源&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;web.xml配置:&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp; 设置标签即可 &emsp;5. 过滤器链(配置多个过滤器)&emsp;&emsp;&emsp;&emsp;&emsp;它可以指向下一个资源，如果还有过滤器，则继续进行下一次的过滤，如果没有过滤器，则会指向资源（servlet）。&emsp;&emsp;&emsp;&emsp;&emsp;执行顺序：如果有两个过滤器：过滤器A和过滤器B&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp; 1. 过滤器A&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp; 2. 过滤器B&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp; 3. 资源执行&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp; 4. 过滤器B&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp; 5. 过滤器A&emsp;&emsp;&emsp;&emsp;&emsp;过滤器先后顺序问题：&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp; 1. 注解配置：按照类名的字符串比较规则比较，值小的先执行&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;* 如： AFilter 和 BFilter，AFilter就先执行了。&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp; 2. web.xml配置： 谁定义在上边，谁先执行","link":"/2019/09/01/JavaWeb三大组件之Filter复习笔记/"},{"title":"第一章：软件需求基础","text":"在现实生活中我们往往会发现一些问题，并希望通过软件系统来解决这些问题，一个软件系统实现前，用户的需求可能比较少也比较模糊，那么需求工程师如何整理和挖掘用户的需求，并建立相应的模型，撰写规范化的文档，以有效指导系统的开发实现，达到满足客户的需求呢？ 什么是需求？在谈需求之前我们先要了解软件和软件工程； 什么是软件？ 软件就是一系列按照特定顺序组织的计算机数据和指令的集合。可以说是程序加文档的集合。程序就是一连串的计算机指令。文档就是相应的文字材料，包括软件使用说明书等。 软件的分类： 系统软件 应用软件 中间件 什么是软件工程？ 软件工程的定义 随着软件规模的越来越大，软件的开发远比编程要复杂，软件设计和开发成为一种工程活动。软件工程要解决的实际问题范围广泛，没有行业和领域的限制，需要客户和用户的紧密合作。 软件工程的各个阶段 项目计划-&gt;需求分析-&gt;项目设计-&gt;编码-&gt;测试-&gt;发布与维护 传统需求处理认为:软件工程的“需求分析”阶段为需求处理过程。 系统化的需求工程认为:软件工程前期的需求工作+软件工程的需求分析阶段=软件需求工程 什么是需求？ 【IEEE1990】对需求的定义： 需求是用户为了解决问题或达到某些目标所需要的条件或能力； 系统或系统部件为了满足合同、标准、规范或其他正式文档所规定的要求而需要具备的条件或能力； 对上述两种情况1或2中的一个条件或一种能力的一种文档化表述。 来看个故事：我要一只羊 张新手刚加入一个项目组，项目经理安排他做需求分析，张新手有点不乐意：“需求有什么好分析的啊？客户要 什么就给什么呗，太浪费我这个人才！”一天，客户打电话说：“我要一只羊”。张新手一听，太简单了，写下了需求：“XX 客户需要一只羊。”张新手 叫小李去处理这件事。小李觉得很简单，抓了一只羊就送过去了。结果客户的投诉第二天就来了，项目经理黑着脸训斥张新手，张新手觉得委屈：“我是按照客户的要求做的呀， 怎么就错了呢？” 故事中张新手的问题，就是未发现客户要求的问题。 客户的要求非常不明确。 客户的要求：我要一只羊。 需要一只什么样的羊？活的，死的？品种？毛色？ 需要一只什么样的羊？用来吃？用来当宠物养？还是只是概念意义上的羊：羊玩具，羊样标志等。 此时张新手应发现客户要求不明确的问题，进行分析，实时询问客户：什么时间、地点要这只羊？为什么要这只羊？用这只羊做什么？处理这只羊的过程是什么。（这里有个简易方法，就是 5W+8C，5W就是when,where,who,why,what8C 是非功能性需求，下一节将详细介绍） 此时客户若回答：请你设计一个羊的标志，我要把它作为公司的徽标，挂在办公楼入口处，10 天后公司开业要用。羊的标志具体要求有什么什么。我要的是这样一只羊。 ——如果客户这样说，是不是需求明确多了。张新手如能及时发现客户要求的问题，并分析问题，及时和客户交流，发现和提出比客户自己提出的更清晰明确的要求，就不至于产生这种结果。 软件危机？ 机指落后的软件生产方式无法满足迅速增长的计算机软件需求，从而导致软件开发与维护过程中出现一系列严重问题的现象。 产生软件危机的其中一个原因：用户需求不明确。 在软件开发过程中，用户需求不明确问题主要体现在四个方面： 在软件开发出来之前，用户自己也不清楚软件开发的具体需求； 用户对软件开发需求的描述不精确，可能有遗漏、有二义性、甚至有错误； 在软件开发过程中，用户还提出修改软件开发功能、界面、支撑环境等方面的要求； 软件开发人员对用户需求的理解与用户本来愿望有差异。 这些都给软件开发带来了危机，导致项目失败或部分失败，导致开发成本提高。所以软件需求工程阶段要做的事就是在项目开发前，就做好充分的准备，形成系统解决方案，将一切可能发生的情况均考虑进去，得到用户的确认，然后才进行软件开发的下一步骤。 需求，除了用户提出的要求，还有用户潜在的需求。需求最重要的特点是完整性、正确性和一致性。要做到这三点，非常不容易。 ## **需求的分类** 需求的分类 功能需求 性能需求 质量需求 对外接口 约束 我们把性能需求、质量需求、对外接口、约束归纳为非功能去修，所以需求可以分为两类：功能性需求和非功能性需求。 功能性需求的三个层次 业务需求&gt;用户需求&gt;系统需求 业务需求：业务需求描述组织或客户的高层次目标，定义系统特性。通常来自于高层业务部门。业务需求从总体上描述了为什么要开发软件或系统（即 Why），组织希望达到的目标。业务需求获取后形成的文档为项目前景和范围文档。这些文档描述了组织对将使用的软件系统所要达到的目标的预期期望。 用户需求：用户需求主要指用户使用产品必须要完成什么任务，怎么完成需求，通是在问题定义的基础上进行用户访谈、调查，对用户使用的场景进行整理，从而建立从用户角度的需求。用户需求必须能够体现软件系统将给用户带来的业务价值，或用户要求系统必须能完成的任务。用户需求主要描述了用户使用系统能够做什么事情（即 What）。通过用户需求信息形成的文档为用例说明文档。 系统需求：系统需求是用户对系统行为的期望，一系列的系统需求联系在一起，帮助用户完成任务，达成用户需求，进而满足业务需求。系统需求可以直接映射为系统行为，定义系统中需要实现的功能，描述开发人员需要实现什么。它描述的是开发人员如何设计具体的解决方案来实现这些需求（即 How），是业务需求和用户需求最终实现的目标，其级别比用户需求高一个数量级。系统需求信息都记录在需求规格说明（Software Requirments Specification 即 SRS）文档中。 我们公司楼下有一家餐厅，这家餐厅由于有特色，菜品丰富等优点，名气越来越大，而店面规模有限，出现了餐饮高峰时期顾客人满为患的情况，顾客就餐氛围差、环境嘈杂，大批顾客因排队时间过程而产生不满情绪或直接离开。 餐厅现在遇到的问题： 1.餐厅很有特色，而店面规模有限，造成大量顾客排队。 2.大批顾客因为排队过程产生不满情绪或者直接离开。 这时餐厅老板就有了需要一款餐厅专属 APP 的要求，需求就产生了。 餐厅老板为了在扩充店面尚未完成的情况下，尽可能增加顾客好感度，防止新老客户流失，想要一个餐厅专属 APP，（本课程中统一命名为 Android 点餐系统），用来向顾客提供餐厅信息，和一些预约订餐功能，节约顾客的等候时间，增加顾客的满意度，减少顾客排队困扰，提升餐厅的名气。我们举例分析下Android 点餐系统的部分功能性需求和非功能性需求： 业务需求：（描述为什么要开发系统（why）开发系统的目标是什么，为什么要有这个系统，注意每条需求都应有相应的编号，以便验证需求。）例如：Android 点餐系统的业务需求. YW1：实现线上订餐的有效管理高层次的解决方案 SS1：在线下单、后台管理，实现统一有效管理。系统特性 SF1：1. 客户需要订餐时在线下单、选座。 2. 餐厅后台查看订单准备菜品。 3. 注意特色菜优先展示给客户。 用户需求：（描述系统能够帮助用户做什么（what）例如：Android 点餐系统的点菜下&gt;单用户需求. UR1：在需要订餐时，选择相关菜品及座位信息，填写顾客相关信息，提交订餐单，等&gt;待餐厅反馈信息，并根据反馈信息查看订餐及选座是否成功。 补充说明 PD1： (1) 订餐单的内容包括：订餐人，联系方式，订餐日期，用餐日期，菜品信息，总价，人数，座位信息，特殊说明等 (2) 订餐单的反馈内容包括：订餐人，餐厅信息，订餐日期，用餐日期，菜品信息，总价，人数，座位信息，特殊说明，订餐是否成功等 系统需求：描述达到用户要求的具体流程（how）例如：对于 Android 点餐系统的用户需求 UR1，转化为系统需求 SR1： （1）消费者可以在移动设备上随时查看餐馆所有的菜目、价格、数量等信息。 （2）消费者可以在移动设备上（手机、平板）下单，预订座位，可以取消或修改订单。 （3）餐馆业务人员可以实时查看并处理订单。（4）餐馆业务人员可以更新菜品信息，对系统用户数据进行管理等。 非功能性需求 性能需求： 一个系统或者其组成部分在限定的约束下，完成其指定功能的程度。 主要包括用户在软件响应速度、精度、容量、负载、系统吞吐量，运行时资源消耗等属性要求。 例如，Android 点餐系统中涉及的精度要求: PR1:餐馆要求每笔订单交易误差不得超过 1 元，每天交易额的误差不得超过 1000 元。 例如：Android 点餐系统中涉及的时间特性的要求： (1):前台客户端 PR2：要求登录时间不得超过 0.5 秒，选择菜品、座位后下单的响应时间不得超过1 秒，其他的一些操作响应时间一般不得超过 0.5 秒。 (2):后台服务器 PR3：要求管理员操作保持流畅，用户下单后后台需要在5秒内看见用户的订单。 例如：Android 点餐系统负载的要求： PR:4：系统应允许同时有 200 人在线点餐","link":"/2019/10/12/什么是需求？/"}],"tags":[{"name":"AJAX","slug":"AJAX","link":"/tags/AJAX/"},{"name":"笔记","slug":"笔记","link":"/tags/笔记/"},{"name":"ssm","slug":"ssm","link":"/tags/ssm/"},{"name":"时间格式","slug":"时间格式","link":"/tags/时间格式/"},{"name":"Redis","slug":"Redis","link":"/tags/Redis/"},{"name":"Filter","slug":"Filter","link":"/tags/Filter/"},{"name":"拦截器","slug":"拦截器","link":"/tags/拦截器/"},{"name":"软件工程","slug":"软件工程","link":"/tags/软件工程/"},{"name":"需求工程","slug":"需求工程","link":"/tags/需求工程/"},{"name":"需求基础","slug":"需求基础","link":"/tags/需求基础/"}],"categories":[{"name":"前端","slug":"前端","link":"/categories/前端/"},{"name":"JavaScript","slug":"前端/JavaScript","link":"/categories/前端/JavaScript/"},{"name":"JAVA","slug":"JAVA","link":"/categories/JAVA/"},{"name":"数据库","slug":"数据库","link":"/categories/数据库/"},{"name":"SSM","slug":"JAVA/SSM","link":"/categories/JAVA/SSM/"},{"name":"Redis","slug":"数据库/Redis","link":"/categories/数据库/Redis/"},{"name":"JavaWeb","slug":"JAVA/JavaWeb","link":"/categories/JAVA/JavaWeb/"},{"name":"软件工程","slug":"软件工程","link":"/categories/软件工程/"},{"name":"软件需求工程","slug":"软件工程/软件需求工程","link":"/categories/软件工程/软件需求工程/"}]}